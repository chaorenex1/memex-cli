version = 1

# 默认 profile
active_profile = "default"

[profiles.default]
# 引用下面的模块配置
runner = "runner.default"
memory = "memory.default"
policy = "policy.default"
observability = "obs.default"

[profiles.ci]
runner = "runner.ci"
memory = "memory.ci"
policy = "policy.ci"
observability = "obs.ci"


[runner.default]
# codecli 可执行文件（留空则走 PATH 探测）
codecli_path = "codecli"

# 子进程工作目录（空 = 继承当前）
cwd = ""

# 额外环境变量（会合并到子进程 env）
env = { }

# stdin 控制协议：off / jsonl（你后面要的 stdin 控制通道）
stdin_protocol = "jsonl"

# 控制通道开关（控制消息与业务输入分流时有用）
control_channel = true

# 进程超时（0 = 不超时，但不推荐）
timeout_ms = 0

# 优雅退出等待；超时则强杀
kill_grace_ms = 3000

# stdout/stderr 处理
tee = "both"          # off|stdout|stderr|both
line_buffered = true  # 是否按行 flush（利于 JSONL 事件解析）

# 事件落盘（空=不落盘）
events_out = ""

# Windows 相关（重点：不弹窗、信号兼容）
[runner.default.windows]
creation_flags = ["NO_WINDOW"]  # 你的 tokio/Windows 需求可以映射到这里
ctrlc_forward = true

[runner.default.unix]
forward_signals = ["SIGINT", "SIGTERM"]

[runner.default.events_out]
enabled = true
path = "./run.events.jsonl"
channel_capacity = 2048
drop_when_full = true



[memory.default]
enabled = true

# 服务端地址（例如 https://api.xxx.com ）
base_url = "http://127.0.0.1:8000"

# 认证（按你后端实现：Bearer / header / query）
auth_type = "bearer"         # bearer|header|none
token = ""                   # 推荐留空，走 token_file 或 env
token_file = ""              # 例如 ~/.config/memwrap/token
header_name = "Authorization" # auth_type=header 时用

# QA 维度（detail 接口要求 project_id query 参数）
project_id = "default-project"

# HTTP 行为
timeout_ms = 5000
connect_timeout_ms = 1500
max_retries = 2
retry_backoff_ms = 200
concurrency = 8

# 端点路径（默认按 OpenAPI；允许覆盖以兼容网关前缀）:contentReference[oaicite:4]{index=4}
endpoints = { 
  qa_search = "/v1/qa/search",
  qa_candidate = "/v1/qa/candidates",
  qa_hit = "/v1/qa/hit",
  qa_validate = "/v1/qa/validate",
  qa_expire = "/v1/qa/expire",
  qa_detail = "/v1/qa/{qa_id}"
}

# 查询与写回的默认参数（可被 Policy 覆盖）
[memory.default.defaults]
namespace = "global"
time_sensitivity = "medium"
tags = []


[memory.default]
enabled = true

# 服务端地址（例如 https://api.xxx.com ）
base_url = "http://127.0.0.1:8000"

# 认证（按你后端实现：Bearer / header / query）
auth_type = "bearer"         # bearer|header|none
token = ""                   # 推荐留空，走 token_file 或 env
token_file = ""              # 例如 ~/.config/memwrap/token
header_name = "Authorization" # auth_type=header 时用

# QA 维度（detail 接口要求 project_id query 参数）
project_id = "default-project"

# HTTP 行为
timeout_ms = 5000
connect_timeout_ms = 1500
max_retries = 2
retry_backoff_ms = 200
concurrency = 8

# 端点路径（默认按 OpenAPI；允许覆盖以兼容网关前缀）:contentReference[oaicite:4]{index=4}
endpoints = { 
  qa_search = "/v1/qa/search",
  qa_candidate = "/v1/qa/candidates",
  qa_hit = "/v1/qa/hit",
  qa_validate = "/v1/qa/validate",
  qa_expire = "/v1/qa/expire",
  qa_detail = "/v1/qa/{qa_id}"
}

# 查询与写回的默认参数（可被 Policy 覆盖）
[memory.default.defaults]
namespace = "global"
time_sensitivity = "medium"
tags = []


[policy.default]
# 是否自动 search
search_on_start = true

# search 的 top_k
top_k = 5

# 置信门槛：低于阈值不“命中写回 hit”
min_score_to_hit = 0.65

# 是否自动写 hit（用于统计/学习）
auto_hit = true

# 是否自动产生 candidate（生成答案后，走 Gatekeeper 决策）
auto_candidate = true

# 是否自动 validate（你要的 qa_validate_and_update 流程可挂这里）
auto_validate = true

# Gatekeeper 规则（示例）
[policy.default.gatekeeper]
require_no_strong_retrieval = true
require_reusable = true
require_no_secrets = true
min_structure_score = 0.7

# 退避/熔断（控制 channel 断线、API 不可用时）
[policy.default.resilience]
circuit_breaker_enabled = true
failure_threshold = 5
cooldown_ms = 30000


[obs.default]
service_name = "memwrap"
trace = true
metrics = true

# span 命名前缀
span_root = "memwrap.run"

# JSONL 结构化日志
json_logs = true



